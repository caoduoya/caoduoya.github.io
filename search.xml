<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>http相关知识</title>
      <link href="/2020/03/06/http-xiang-guan-zhi-shi/"/>
      <url>/2020/03/06/http-xiang-guan-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP相关知识"><a href="#HTTP相关知识" class="headerlink" title="HTTP相关知识"></a>HTTP相关知识</h2><h3 id="1-HTTP有什么特点"><a href="#1-HTTP有什么特点" class="headerlink" title="1. HTTP有什么特点"></a>1. HTTP有什么特点</h3><ul><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由 <code>Content-Type</code> 加以标记</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接 (深入-持久连接、管线化)</li><li>无状态：HTTP协议是无状态协议( <code>Cookie</code> 的出现)</li></ul><h3 id="2-http和https协议有什么区别"><a href="#2-http和https协议有什么区别" class="headerlink" title="2. http和https协议有什么区别"></a>2. http和https协议有什么区别</h3><blockquote><p>http: 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（Tcp），用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少</p><p>https: 是以安全为目标的HTTP通道，简单讲是 <code>HTTP</code> 的安全版，即 <code>HTTP</code> 下加入 <code>SSL</code> 层，<code>HTTPS</code> 的安全基础是 <code>SSL</code> ，因此加密的详细内容就需要 <code>SSL</code></p></blockquote><ul><li><code>http</code> 是超文本传输协议，信息是明文传输，<code>https</code> 则是具有安全性的 <code>ssl</code> 加密传输协议</li><li><code>http</code> 和 <code>https</code> 使用的是完全不同的连接方式，用的端口也不一样，前者是 <code>80</code> ，后者是 <code>443</code></li><li><code>http</code> 的连接很简单，是无状态的；<code>HTTPS</code> 协议是由 <code>SSL+HTTP</code> 协议构建的可进行加密传输、身份认证的网络协议，比 <code>http</code> 协议安全</li></ul><h3 id="3-http状态码有那些？分别代表是什么意思"><a href="#3-http状态码有那些？分别代表是什么意思" class="headerlink" title="3. http状态码有那些？分别代表是什么意思"></a>3. http状态码有那些？分别代表是什么意思</h3><p>常用 <code>http</code> 状态码：</p><ul><li><code>200</code> <code>OK</code> 服务器成功处理了请求</li><li><code>301/302</code> <code>Moved Permanently</code>（重定向）请求的URL已移走</li><li><code>404</code> <code>Not Found</code> (页面丢失)未找到资源</li><li><code>403</code> 服务器拒绝请求</li><li><code>408</code> （请求超时） 服务器等候请求时发生超时</li><li><code>501</code> <code>Internal Server Error</code> 服务器遇到一个错误，使其无法对请求提供服务</li><li><code>502</code> （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应</li><li><code>504</code> （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求</li></ul><h3 id="4-Http报文"><a href="#4-Http报文" class="headerlink" title="4.Http报文"></a>4.Http报文</h3><p><code>HTTP</code> 报文是面向文本的，报文中的每一个字段都是一些 <code>ASCII</code> 码串，各个字段的长度是不确定的。<code>HTTP</code> 有两类报文：<strong>请求报文和响应报文</strong></p><p>HTTP的这两种报文都由三部分组成：开始行、首部行、实体主体</p><h3 id="5-为什么利用多个域名来存储网站资源会更有效"><a href="#5-为什么利用多个域名来存储网站资源会更有效" class="headerlink" title="5.为什么利用多个域名来存储网站资源会更有效"></a>5.为什么利用多个域名来存储网站资源会更有效</h3><ul><li><code>CDN</code> 缓存更方便</li><li>突破浏览器并发限制</li><li>节约 <code>cookie</code> 带宽</li><li>节约主域名的连接数，优化页面响应速度</li><li>防止不必要的安全问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈hybrid</title>
      <link href="/2020/03/05/tan-hybrid/"/>
      <url>/2020/03/05/tan-hybrid/</url>
      
        <content type="html"><![CDATA[<h1 id="谈hybrid"><a href="#谈hybrid" class="headerlink" title="谈hybrid"></a>谈hybrid</h1><p>hybrid为”混合”,是前端和客户端的混合开发,需要前端开发人员和客户端开发人员配合完成,在某个环节也会涉及到server端</p><h2 id="hybrid和h5的区别"><a href="#hybrid和h5的区别" class="headerlink" title="hybrid和h5的区别"></a>hybrid和h5的区别</h2><p>相比优点</p><p>1.体验更好，和NA体验基本上是一致的</p><p>2.看快速迭代，不需要app审核</p><p>相比缺点</p><p>1.开发成本高，联调，测试，查bug较麻烦</p><p>2.运维成本高。</p><p>适用场景</p><ul><li>不是所有场景都适合使用 <code>hybrid</code></li><li>使用 <code>NA</code> ：体验要求极致，变化不频繁</li><li>使用 <code>hybrid</code> ：体验要求高，变化频繁</li><li>使用 <code>h5</code> ：体验无要求，不常用</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ul><li>前端做好静态页面（<code>html js css</code>），将文件交给客户端</li><li>客户端拿到前端静态页面，以文件形式存储在 <code>app</code> 中</li><li>客户端在一个 <code>webview</code> 中</li><li>使用 <code>file</code> 协议加载静态页面</li></ul>]]></content>
      
      
      <categories>
          
          <category> app </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 混合式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化</title>
      <link href="/2020/03/04/qian-duan-xing-neng-you-hua/"/>
      <url>/2020/03/04/qian-duan-xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="前端性能详谈"><a href="#前端性能详谈" class="headerlink" title="前端性能详谈"></a>前端性能详谈</h2><p>自己去将关于性能的优化的一些知识进行了整理，方便自己去学习和大家阅读</p><h3 id="1-DNS-预解析"><a href="#1-DNS-预解析" class="headerlink" title="1 DNS 预解析"></a>1 DNS 预解析</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dns-prefetch<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>//blog.poetries.top<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><h3 id="2-缓存"><a href="#2-缓存" class="headerlink" title="2 缓存"></a>2 缓存</h3><ul><li>缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度</li><li>通常浏览器缓存策略分为两种：强缓存和协商缓存</li></ul><p><strong>强缓存</strong></p><p>实现强缓存可以通过两种响应头实现：<code>Expires</code>和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，<code>state code</code>为 <code>200</code></p><pre class=" language-text"><code class="language-text">Expires: Wed, 22 Oct 2018 08:41:00 GMT</code></pre><p><code>Expires</code> 是 <code>HTTP / 1.0</code> 的产物，表示资源会在 <code>Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 <code>Expires</code> 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p><pre class=" language-text"><code class="language-text">Cache-control: max-age=30</code></pre><p><code>Cache-Control</code> 出现于 <code>HTTP / 1.1</code>，优先级高于 <code>Expires</code> 。该属性表示资源会在 <code>30</code> 秒后过期，需要再次请求</p><p><strong>协商缓存</strong></p><ul><li>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304</li><li>协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式</li></ul><pre><code>Last-Modified` 和 `If-Modified-Since</code></pre><ul><li><code>Last-Modified</code> 表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code>的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来</li><li>但是如果在本地打开缓存文件，就会造成 <code>Last-Modified</code> 被修改，所以在 <code>HTTP / 1.1</code> 出现了 <code>ETag</code></li></ul><pre><code>ETag` 和 `If-None-Match</code></pre><ul><li><code>ETag</code> 类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 <code>ETag</code> 优先级比 <code>Last-Modified</code> 高</li></ul><p><strong>选择合适的缓存策略</strong></p><p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p><ul><li>对于某些不需要缓存的资源，可以使用 <code>Cache-control: no-store</code> ，表示该资源不需要缓存</li><li>对于频繁变动的资源，可以使用 <code>Cache-Control: no-cache</code> 并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li><li>对于代码文件来说，通常使用 <code>Cache-Control: max-age=31536000</code> 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件</li></ul><h3 id="3-使用-HTTP-2-0"><a href="#3-使用-HTTP-2-0" class="headerlink" title="3 使用 HTTP / 2.0"></a>3 使用 HTTP / 2.0</h3><ul><li>因为浏览器会有并发请求限制，在 <code>HTTP / 1.1</code> 时代，每个请求都需要建立和断开，消耗了好几个 <code>RTT</code> 时间，并且由于 <code>TCP</code> 慢启动的原因，加载体积大的文件会需要更多的时间</li><li>在 <code>HTTP / 2.0</code> 中引入了多路复用，能够让多个请求使用同一个 <code>TCP</code> 链接，极大的加快了网页的加载速度。并且还支持 <code>Header</code> 压缩，进一步的减少了请求的数据大小</li></ul><h3 id="4-预加载"><a href="#4-预加载" class="headerlink" title="4 预加载"></a>4 预加载</h3><ul><li>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载</li><li>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://example.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><blockquote><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好</p></blockquote><h3 id="5-预渲染"><a href="#5-预渲染" class="headerlink" title="5 预渲染"></a>5 预渲染</h3><blockquote><p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prerender<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://poetries.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><ul><li>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染</li></ul><h3 id="6-懒执行与懒加载"><a href="#6-懒执行与懒加载" class="headerlink" title="6 懒执行与懒加载"></a>6 懒执行与懒加载</h3><p><strong>懒执行</strong></p><ul><li>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒</li></ul><p><strong>懒加载</strong></p><ul><li>懒加载就是将不关键的资源延后加载</li></ul><p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 <code>src</code> 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 <code>src</code> 属性，这样图片就会去下载资源，实现了图片懒加载</p><ul><li>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等</li></ul><h3 id="7-文件优化"><a href="#7-文件优化" class="headerlink" title="7 文件优化"></a>7 文件优化</h3><p><strong>图片优化</strong></p><p>对于如何优化图片，有 2 个思路</p><ul><li>减少像素点</li><li>减少每个像素点能够显示的颜色</li></ul><p><strong>图片加载优化</strong></p><ul><li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 <code>CSS</code> 去代替。</li><li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片</li><li>小图使用 <code>base64</code>格式</li><li>将多个图标文件整合到一张图片中（雪碧图）</li><li>选择正确的图片格式：<ul><li>对于能够显示 <code>WebP</code> 格式的浏览器尽量使用 <code>WebP</code> 格式。因为 <code>WebP</code> 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><li>小图使用 <code>PNG</code>，其实对于大部分图标这类图片，完全可以使用 <code>SVG</code> 代替</li><li>照片使用 <code>JPEG</code></li></ul></li></ul><p><strong>其他文件优化</strong></p><ul><li><code>CSS</code>文件放在 <code>head</code> 中</li><li>服务端开启文件压缩功能</li><li>将 <code>script</code> 标签放在 <code>body</code> 底部，因为 <code>JS</code> 文件执行会阻塞渲染。当然也可以把 <code>script</code> 标签放在任意位置然后加上 <code>defer</code> ，表示该文件会并行下载，但是会放到 <code>HTML</code> 解析完成后顺序执行。对于没有任何依赖的 <code>JS</code>文件可以加上 <code>async</code> ，表示加载和渲染后续文档元素的过程将和 <code>JS</code> 文件的加载与执行并行无序进行。 执行 <code>JS</code>代码过长会卡住渲染，对于需要很多时间计算的代码</li><li>可以考虑使用 <code>Webworker</code>。<code>Webworker</code>可以让我们另开一个线程执行脚本而不影响渲染。</li></ul><p><strong>CDN</strong></p><p>静态资源尽量使用 <code>CDN</code> 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 <code>CDN</code> 域名。对于 <code>CDN</code> 加载静态资源需要注意 <code>CDN</code> 域名要与主站不同，否则每次请求都会带上主站的 <code>Cookie</code></p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深浅拷贝</title>
      <link href="/2020/03/03/shen-qian-kao-bei/"/>
      <url>/2020/03/03/shen-qian-kao-bei/</url>
      
        <content type="html"><![CDATA[<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p><strong>浅拷贝</strong></p><p>首先可以通过 Object.assign来解决这个问题，很多人认为这个函数是用来深拷贝的。其实并不是，Object.assign 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>  age<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token keyword">let</span> b <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>a<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span></code></pre><p>另外我们还可以通过展开运算符 … 来实现浅拷贝</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>  age<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>a <span class="token punctuation">}</span>a<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span></code></pre><p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用到深拷贝了</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>  age<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  jobs<span class="token punctuation">:</span> <span class="token punctuation">{</span>    first<span class="token punctuation">:</span> <span class="token string">'FE'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>a <span class="token punctuation">}</span>a<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token string">'native'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// native</span></code></pre><p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。</p><p><strong>深拷贝</strong></p><p>这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>  age<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  jobs<span class="token punctuation">:</span> <span class="token punctuation">{</span>    first<span class="token punctuation">:</span> <span class="token string">'FE'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> b <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token string">'native'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// FE</span></code></pre><p><strong>但是该方法也是有局限性的</strong>：</p><ul><li>会忽略 undefined</li><li>会忽略 symbol</li><li>不能序列化函数</li><li>不能解决循环引用的对象</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  b<span class="token punctuation">:</span> <span class="token punctuation">{</span>    c<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    d<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span>obj<span class="token punctuation">.</span>c <span class="token operator">=</span> obj<span class="token punctuation">.</span>bobj<span class="token punctuation">.</span>e <span class="token operator">=</span> obj<span class="token punctuation">.</span>aobj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">=</span> obj<span class="token punctuation">.</span>cobj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>d <span class="token operator">=</span> obj<span class="token punctuation">.</span>bobj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>e <span class="token operator">=</span> obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c<span class="token keyword">let</span> newObj <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newObj<span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js闭包详谈</title>
      <link href="/2020/03/02/js-bi-bao-xiang-tan/"/>
      <url>/2020/03/02/js-bi-bao-xiang-tan/</url>
      
        <content type="html"><![CDATA[<h1 id="js闭包详谈"><a href="#js闭包详谈" class="headerlink" title="js闭包详谈"></a>js闭包详谈</h1><p>闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span>  <span class="token keyword">function</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> B<span class="token punctuation">}</span></code></pre><p>循环中使用闭包解决 var 定义函数的问题</p><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> i<span class="token operator">*</span><span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>首先因为 <code>setTimeout</code> 是个异步函数，所有会先把循环全部执行完毕，这时候 <code>i</code> 就是 <code>6</code> 了，所以会输出一堆 <code>6</code>。</li><li>解决办法两种，第一种使用闭包</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> j <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>第二种就是使用 <code>setTimeout</code> 的第三个参数</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> j <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> i<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>第三种就是使用 <code>let</code> 定义 <code>i</code> 了</p><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> i<span class="token operator">*</span><span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>因为对于 <code>let</code> 来说，他会创建一个块级作用域，相当于</p><pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 形成块级作用域</span>  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span>  <span class="token punctuation">{</span>    <span class="token keyword">let</span> ii <span class="token operator">=</span> i    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> i<span class="token operator">*</span><span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  i<span class="token operator">++</span>  <span class="token punctuation">{</span>    <span class="token keyword">let</span> ii <span class="token operator">=</span> i  <span class="token punctuation">}</span>  i<span class="token operator">++</span>  <span class="token punctuation">{</span>    <span class="token keyword">let</span> ii <span class="token operator">=</span> i  <span class="token punctuation">}</span>  <span class="token operator">...</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue使用axios</title>
      <link href="/2020/03/01/vue-shi-yong-axios/"/>
      <url>/2020/03/01/vue-shi-yong-axios/</url>
      
        <content type="html"><![CDATA[<h1 id="vue使用axios"><a href="#vue使用axios" class="headerlink" title="vue使用axios"></a>vue使用axios</h1><p>1.在mina.js中写下面代码</p><pre><code>import Axios from &quot;axios&quot;;Vue.prototype.HOST = &quot;http://localhost:4000&quot;;Vue.prototype.$axios = Axios;</code></pre><p>2.在页面使用的时候是</p><pre class=" language-js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>$axios​    <span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>HOST <span class="token operator">+</span> <span class="token string">"/api/login"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>​     username<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>username<span class="token punctuation">,</span>​     password<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>password​    <span class="token punctuation">}</span><span class="token punctuation">)</span>​    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token operator">*</span>result<span class="token operator">*</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>​     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>​     <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> result<span class="token punctuation">.</span>data<span class="token punctuation">.</span>msg<span class="token punctuation">;</span>​    <span class="token punctuation">}</span><span class="token punctuation">)</span>​    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token operator">*</span>err<span class="token operator">*</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>​     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>​    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解跨越问题</title>
      <link href="/2020/03/01/liao-jie-kua-yue-wen-ti/"/>
      <url>/2020/03/01/liao-jie-kua-yue-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="了解跨域问题"><a href="#了解跨域问题" class="headerlink" title="了解跨域问题?"></a>了解跨域问题?</h3><p>首先了解下浏览器的同源策略 同源策略<code>/SOP（Same origin policy）</code>是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到<code>XSS</code>、<code>CSFR</code>等攻击。所谓同源是指”<strong>协议+域名+端口</strong>“三者相同，即便两个不同的域名指向同一个ip地址，也非同源</p><h4 id="怎样解决跨域问题的呢？"><a href="#怎样解决跨域问题的呢？" class="headerlink" title="怎样解决跨域问题的呢？"></a>怎样解决跨域问题的呢？</h4><ul><li><strong>通过jsonp跨域</strong></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 传参并指定回调执行函数为onBack</span>script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://www.....:8080/login?user=admin&amp;callback=onBack'</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 回调执行函数</span><span class="token keyword">function</span> <span class="token function">onBack</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><strong>document.domain + iframe跨域</strong></li></ul><blockquote><p>此方案仅限主域相同，子域不同的跨域应用场景</p></blockquote><p>1.）父窗口：(<a href="http://www.domain.com/a.html" target="_blank" rel="noopener">http://www.domain.com/a.html</a>)</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>iframe<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://child.domain.com/b.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'domain.com'</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token string">'admin'</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>2.）子窗口：(<a href="http://child.domain.com/b.html" target="_blank" rel="noopener">http://child.domain.com/b.html</a>)</p><pre class=" language-javascript"><code class="language-javascript">document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'domain.com'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取父窗口中变量</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'get js data from parent ---> '</span> <span class="token operator">+</span> window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><strong>nginx代理跨域</strong></li><li><strong>nodejs中间件代理跨域</strong></li><li><strong>后端在头部信息里面设置安全域名</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue的路由守卫</title>
      <link href="/2020/03/01/vue-de-lu-you-shou-wei/"/>
      <url>/2020/03/01/vue-de-lu-you-shou-wei/</url>
      
        <content type="html"><![CDATA[<h1 id="vue的路由守卫"><a href="#vue的路由守卫" class="headerlink" title="vue的路由守卫"></a>vue的路由守卫</h1><p>vue路由守卫实现代码</p><pre><code>router.beforeEach((to,from,next)=&gt;{  if(to.path == &#39;/login&#39;){    next();  }else{    alert(&#39;您还没有登录，请先登录&#39;);    next(&#39;/login&#39;);  }})</code></pre><h3 id="各参数含义"><a href="#各参数含义" class="headerlink" title="各参数含义"></a>各参数含义</h3><p>1.to 表示将要跳转到的组件</p><p>2.from原组件</p><p>3.next()进入到下一个组件的钩子函数</p><p>4.next(/login)进入指定的组件的钩子函数</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的使用</title>
      <link href="/2020/03/01/git-de-shi-yong/"/>
      <url>/2020/03/01/git-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h1><h2 id="1-本地拉取远程仓库代码"><a href="#1-本地拉取远程仓库代码" class="headerlink" title="1.本地拉取远程仓库代码"></a>1.本地拉取远程仓库代码</h2><p>1.本地新建一个文件夹</p><p>2.初始化本地Git仓库(把本地文件夹初始化为一个Git可以管理的版本库)</p><pre><code>git init</code></pre><p>3.将gitee(码云)中的项目地址复制过来</p><pre><code>git clone &quot;仓库地址&quot;</code></pre><p>4.执行完之后，就会发现代码已经下载到了我们的新建文件夹中</p><h2 id="2-本地连接已经创建好的仓库"><a href="#2-本地连接已经创建好的仓库" class="headerlink" title="2.本地连接已经创建好的仓库"></a>2.本地连接已经创建好的仓库</h2><p>1.步骤接拉取代码步骤之后</p><p>2.把文件添加到本地版本库</p><pre><code>git add 文件名</code></pre><p>3.将修改提交到仓库</p><pre><code>git commit -m &quot;注释&quot;</code></pre><p>4.关联一个远程仓库</p><pre><code>git remote add origin &quot;仓库地址&quot;</code></pre><p>5.最新修改推送到远程仓库</p><pre><code>git push -u origin &quot;分支名&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
